<!--
/*
*   Project: DogeLock - Biometric Self-Custodial Dogecoin Wallet
*   Author: Dogecoin Foundation - https://x.com/inevitable360
*   Description: A secure OpenSource Dogecoin Wallet for everyone that want to do it better
*   License: Well, do what you want with this, be creative, you have the wheel, just reenvent and do it better! Do Only Good Everyday
*/
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#202F36">
  <title>Doge Lock - Self-Custodial Biometric Dogecoin Wallet</title>
  <meta name="description" content="Self-Custodial Biometric Dogecoin Wallet">
  <meta name="keywords" content="dogecoin, doge, wallet, self-custodial, biometric">  
  <meta name="author" content="Dogecoin Foundation">
  <meta name="generator" content="You!">
  <link href="icons/icon-512x512.png" rel="icon" />  
  <link rel="manifest" href="./manifest.json">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue&display=swap" rel="stylesheet">
  <link href="css/doge.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="card p-4">
      <h2 id="walletHeader" class="text-center mb-4">
        <img src="icons/icon-512x512.png" style="max-width: 100px;"><br>√êogeLock <p class="text-muted">Biometric Dogecoin Wallet</p>
      </h2>
      <div id="result" class="text-center mt-4 text-muted"></div>
      <button id="generateButton" class="btn btn-generate btn-lg w-100">
        <i class="fa-solid fa-fingerprint"></i> Generate Biometric Wallet
      </button>
      <button id="biometricButton" class="btn btn-view btn-lg w-100 d-none">
        <i class="fa-solid fa-fingerprint"></i> Such Wallet
      </button>
      <button id="installButton" class="btn btn-light w-100 mt-2 d-none">
        <i class="fa-solid fa-download"></i> So Install App
      </button>
    </div>
  </div>

  <nav class="navbar-bottom d-none" id="bottomMenu">
    <div class="container d-flex" style="padding-top: 0px;">
      <button class="btn wallet-btn" id="walletBtn" style="width: 80px;">
        <i class="fa-solid fa-wallet"></i>
      </button>
      <button class="btn paw-btn" id="sendBtn">
        <i class="fa-solid fa-paw"></i>
      </button>
      <button class="btn config-btn" id="configBtn" style="width: 80px;">
        <i class="fa-solid fa-gear"></i>
      </button>
    </div>
  </nav>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://unpkg.com/@zxing/library@latest/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="js/bitcoinjs-lib.js"></script>

  <script>
    const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    const FIXED_CHALLENGE = stringToUint8Array("doge-challenge");

    // Define Dogecoin network parameters
    const dogecoinNetwork = {
      messagePrefix: '\x19Dogecoin Signed Message:\n',
      bip32: {
        public: 0x02facafd,
        private: 0x02fac398
      },
      pubKeyHash: 0x1e, // Dogecoin addresses start with 'D'
      scriptHash: 0x16,
      wif: 0x9e // Private keys in WIF format
    };

    function hexToBytes(hex) {
      const bytes = [];
      for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substr(i, 2), 16));
      }
      return bytes;
    }

    function bytesToHex(bytes) {
      return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function toBase58(bytes) {
      let num = BigInt('0x' + bytesToHex(bytes));
      let result = '';
      while (num > 0n) {
        const remainder = Number(num % 58n);
        result = BASE58_ALPHABET[remainder] + result;
        num = num / 58n;
      }
      for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
        result = '1' + result;
      }
      return result;
    }

    function getChecksum(bytes) {
      const hexPayload = bytesToHex(bytes);
      const wordArray = CryptoJS.enc.Hex.parse(hexPayload);
      const hash1 = CryptoJS.SHA256(wordArray);
      const hash2 = CryptoJS.SHA256(hash1);
      return hexToBytes(hash2.toString(CryptoJS.enc.Hex)).slice(0, 4);
    }

    function generateWif(privateKeyBytes, compressed = true) {
      const version = [0x9e];
      let payload = version.concat(privateKeyBytes);
      if (compressed) payload.push(0x01);
      const checksum = getChecksum(payload);
      const fullPayload = payload.concat(checksum);
      return toBase58(fullPayload);
    }

    function hash160(bytes) {
      const sha256 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(bytesToHex(bytes)));
      const ripemd160 = CryptoJS.RIPEMD160(sha256);
      return hexToBytes(ripemd160.toString(CryptoJS.enc.Hex));
    }

    function generateAddressFromPublicKey(publicKeyBytes) {
      const pubKeyHash = hash160(publicKeyBytes);
      const payload = [0x1e].concat(pubKeyHash);
      const checksum = getChecksum(payload);
      const fullPayload = payload.concat(checksum);
      return toBase58(fullPayload);
    }

    function stringToUint8Array(str) {
      return Uint8Array.from(str, c => c.charCodeAt(0));
    }

    function base64UrlToUint8Array(base64url) {
      if (!base64url) throw new Error("Invalid base64url input");
      const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
      const padding = '='.repeat((4 - base64.length % 4) % 4);
      return Uint8Array.from(atob(base64 + padding), c => c.charCodeAt(0));
    }

    function uint8ArrayToBase64Url(arr) {
      const uint8Arr = arr instanceof Uint8Array ? arr : new Uint8Array(arr);
      const base64 = btoa(String.fromCharCode(...uint8Arr));
      return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function registerWebAuthn() {
      if (!window.PublicKeyCredential) {
        throw new Error("Much sad! WebAuthn not supported.");
      }

      const encryptionKey = crypto.getRandomValues(new Uint8Array(32));
      const publicKey = {
        challenge: FIXED_CHALLENGE,
        rp: { name: "DogeCoinGenix" },
        user: {
          id: encryptionKey,
          name: "wallet",
          displayName: "DogeLock Biometric",
          userHandle: encryptionKey
        },
        pubKeyCredParams: [{ type: "public-key", alg: -7 }],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          userVerification: "required",
          requireResidentKey: true
        },
        timeout: 60000,
      };

      const credential = await navigator.credentials.create({ publicKey });
      if (!credential) throw new Error("Much sad! Registration failed.");

      const response = credential.response;
      const webAuthnPublicKey = new Uint8Array(response.getPublicKey());
      if (!webAuthnPublicKey || webAuthnPublicKey.length === 0) {
        throw new Error("Much sad! Authenticator did not return a public key.");
      }

      const publicKeyHex = bytesToHex(webAuthnPublicKey);
      const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKeyHex));
      const privateKeyBytes = hexToBytes(hash.toString(CryptoJS.enc.Hex)).slice(0, 32);

      const ec = new elliptic.ec('secp256k1');
      const keyPair = ec.keyFromPrivate(privateKeyBytes);
      const wif = generateWif(privateKeyBytes, true);
      const dogePublicKeyBytes = keyPair.getPublic(true, 'array');
      const address = generateAddressFromPublicKey(dogePublicKeyBytes);

      const { encrypted, iv } = await encryptData(wif, encryptionKey);

      return {
        credentialId: uint8ArrayToBase64Url(credential.rawId),
        encryptedWif: encrypted,
        iv: iv,
        address: address,
        privateKey: wif
      };
    }

    async function authenticateWebAuthn(credentialId) {
      if (!window.PublicKeyCredential) {
        throw new Error("Much sad! WebAuthn not supported.");
      }

      const publicKey = {
        challenge: FIXED_CHALLENGE,
        allowCredentials: [{
          type: "public-key",
          id: base64UrlToUint8Array(credentialId)
        }],
        userVerification: "required",
        timeout: 60000,
      };

      const assertion = await navigator.credentials.get({ publicKey });
      if (!assertion) throw new Error("Much sad! Authentication failed.");

      const userHandle = assertion.response.userHandle;
      if (!userHandle) throw new Error("Much sad! Authenticator did not return userHandle");

      const encryptionKey = new Uint8Array(userHandle);
      const storedIv = localStorage.getItem('dogeIv');
      const decryptedWif = await decryptData(storedEncryptedWif, storedIv, encryptionKey);
      const address = getAddressFromWif(decryptedWif);

      return {
        credentialId: assertion.id,
        privateKey: decryptedWif,
        address: address
      };
    }

    async function encryptData(data, key) {
      const aesKey = await crypto.subtle.importKey(
        "raw",
        key,
        "AES-GCM",
        true,
        ["encrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        aesKey,
        stringToUint8Array(data)
      );
      return { encrypted: uint8ArrayToBase64Url(encrypted), iv: uint8ArrayToBase64Url(iv) };
    }

    async function decryptData(encryptedData, iv, key) {
      const aesKey = await crypto.subtle.importKey(
        "raw",
        key,
        "AES-GCM",
        true,
        ["decrypt"]
      );
      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: base64UrlToUint8Array(iv) },
        aesKey,
        base64UrlToUint8Array(encryptedData)
      );
      return new TextDecoder().decode(decrypted);
    }

    function getAddressFromWif(wif) {
      const ec = new elliptic.ec('secp256k1');
      const base58ToBytes = (base58) => {
        let num = BigInt(0);
        for (let i = 0; i < base58.length; i++) {
          const charIndex = BASE58_ALPHABET.indexOf(base58[i]);
          if (charIndex === -1) throw new Error("Invalid Base58 character");
          num = num * 58n + BigInt(charIndex);
        }
        const hex = num.toString(16).padStart(64, '0');
        const bytes = hexToBytes(hex);
        while (bytes.length < 37) bytes.unshift(0);
        return bytes;
      };
      const wifBytes = base58ToBytes(wif);
      const privateKeyBytes = wifBytes.slice(1, 33);
      const keyPair = ec.keyFromPrivate(privateKeyBytes);
      const publicKeyBytes = keyPair.getPublic(true, 'array');
      return generateAddressFromPublicKey(publicKeyBytes);
    }

    async function getDogeBalanceAndTransactions(address) {  
      const url = 'https://what-is-dogecoin.com/explorer/biometric/';
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({ 'address': address })
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        return data.status === 'success' ? data : { balance: "0", transactions: [] };
      } catch (error) {
        console.error("Error fetching Dogecoin data:", error);
        return { balance: "Unable to fetch balance", transactions: [] };
      }
    }

    async function sendDoge(address, destinationAddress, amount, privateKeyWif) {
      try {
        if (typeof bitcoin === 'undefined') {
          throw new Error("Much sad! bitcoinjs-lib is not loaded.");
        }
        if (!bitcoin.TransactionBuilder) {
          throw new Error("Much sad! TransactionBuilder is not available.");
        }
        if (!bitcoin.ECPair) {
          throw new Error("Much sad! ECPair is not available.");
        }

        const walletData = await getDogeBalanceAndTransactions(address);
        const utxos = walletData.transactions
          .filter(tx => tx.tx_type === 'RECEIVED' && !tx.spent_timestamp)
          .map(tx => ({
            txid: tx.tx_hash,
            vout: parseInt(tx.tx_output_n, 10), // Fix: Convert to integer
            value: Math.floor(parseFloat(tx.amount) * 1e8)
          }));

        if (!utxos.length) throw new Error("No unspent outputs available");

        const txb = new bitcoin.TransactionBuilder(dogecoinNetwork);
        const amountSatoshis = Math.floor(parseFloat(amount) * 1e8);
        const fee = 0.01; // 0.01 DOGE in satoshis
        let totalInput = 0;

        for (const utxo of utxos) {
          if (totalInput >= (amountSatoshis + fee)) break;
          txb.addInput(utxo.txid, utxo.vout);
          totalInput += utxo.value;
        }

        if (totalInput < amountSatoshis + fee) {
          throw new Error("Much Sad! Insufficient funds including fee");
        }

        txb.addOutput(destinationAddress, amountSatoshis);

        const change = totalInput - (amountSatoshis + fee);
        if (change > 0) {
          txb.addOutput(address, change);
        }

        const keyPair = bitcoin.ECPair.fromWIF(privateKeyWif, dogecoinNetwork);
        utxos.forEach((utxo, index) => {
          txb.sign(index, keyPair);
        });

        const tx = txb.build();
        const signedTxHex = tx.toHex();

        const url = 'https://what-is-dogecoin.com/explorer/biometric/';
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ 'signed': signedTxHex })
        });

        const data = await response.json();
        return data;
      } catch (error) {
        console.error("Error signing/sending Dogecoin transaction:", error);
        return { status: 'error', message: error.message };
      }
    }

    async function scanQRCode() {
      return new Promise((resolve) => {
        const video = document.createElement('video');
        const reader = new ZXing.BrowserQRCodeReader();
        
        resultElement.innerHTML = `
          <div class="mb-3" style="margin: auto;border: 1px solid gray;border-radius: 10px;overflow: hidden;width: 300px;height: 300px;">
            <video id="video" width="400" height="400" style="margin-top: -50px;margin-left: -45px;"></video>            
          </div>
          <div class="mb-3" style="margin: auto;">
            <button id="stopScan" class="btn btn-generate w-100 mt-2"><i class="fa-solid fa-pen-to-square"></i> Much Insert Manual Payment</button>
          </div>
        `;

        reader.decodeFromVideoDevice(null, 'video', (result, err) => {
          if (result) {
            reader.reset();
            video.remove();
            resolve(result.text);
          }
          if (err && !(err instanceof ZXing.NotFoundException)) {
            console.error(err);
          }
        });

        document.getElementById('stopScan').addEventListener('click', () => {
          reader.reset();
          video.remove();
          resolve(null);
        });
      });
    }

    function formatDateTime(datetime) {
      return new Date(datetime).toLocaleString();
    }

    function trimAddress(address) {
      if (!address) return 'Unknown';
      return address.slice(0, 8) + '...' + address.slice(-8);
    }

    function showTransactionDetails(tx, showWalletView) {
      const container = document.querySelector('.container');
      container.style.display = 'none';
      
      const detailsDiv = document.createElement('div');
      detailsDiv.className = 'transaction-details container';
      detailsDiv.innerHTML = `
      <h5 class="mb-3 w-100"><i class="fa-regular fa-file-lines"></i> Transaction Details</h5>
      <div class="mb-3">  
        <p><strong>Amount:</strong> ${tx.tx_type === 'RECEIVED' ? '+' : '-'}${tx.amount} √ê</p>
        <p><strong>Address:</strong> ${tx.tx_type === 'RECEIVED' ? tx.address : tx.destination_address}</p>
        <p><strong style="word-break:break-all">Hash:</strong> ${tx.tx_hash}</p>
        <p><strong>Confirmations:</strong> ${tx.confirmations}</p>
        <p><strong>Received:</strong> ${formatDateTime(tx.received_timestamp)}</p>
        ${tx.spent_timestamp ? `<p><strong>Spent:</strong> ${formatDateTime(tx.spent_timestamp)}</p>` : ''}
        ${tx.fee ? `<p><strong>Fee:</strong> ${tx.fee} √ê</p>` : ''}
        <p><strong>Status:</strong> ${tx.status}</p>
        <a href="https://sochain.com/tx/DOGE/${tx.tx_hash}" target="_blank" class="btn btn-view w-100 mb-3"><i class="fa-regular fa-file-lines"></i> View on SoChain</a>
        <button class="btn btn-secondary w-100 mb-3" id="backButton"><i class="fa-solid fa-arrow-left"></i> So Back</button>
      </div>   
      `;
      
      document.body.appendChild(detailsDiv);
      
      document.getElementById('backButton').addEventListener('click', () => {
        detailsDiv.remove();
        container.style.display = 'block';
        showWalletView();
      });
    }

    let deferredPrompt;
    const installButton = document.getElementById("installButton");
    let storedCredentialId = localStorage.getItem('dogeCredentialId');
    let storedEncryptedWif = localStorage.getItem('dogeEncryptedWif');
    const generateButton = document.getElementById("generateButton");
    const biometricButton = document.getElementById("biometricButton");
    const resultElement = document.getElementById("result");
    const bottomMenu = document.getElementById("bottomMenu");
    const walletHeader = document.getElementById("walletHeader");
    let balanceInterval = null;
    let isAuthenticated = false;

    function isRunningStandalone() {
      return (window.matchMedia('(display-mode: standalone)').matches) || 
             (window.navigator.standalone === true);
    }

    function isIOS() {
      return /iPhone|iPad|iPod/i.test(navigator.userAgent);
    }

    function hasWallet() {
      return !!(storedCredentialId && storedEncryptedWif);
    }

    function showInstallPrompt() {
      if (isRunningStandalone() || hasWallet()) {
        installButton.classList.add("d-none");
        return;
      }
      installButton.classList.remove("d-none");
      if (deferredPrompt) {
        installButton.addEventListener("click", async () => {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          if (outcome === 'accepted') {
            console.log('User installed the app');
            installButton.classList.add("d-none");
          }
          deferredPrompt = null;
        });
      } else if (isIOS()) {
        installButton.addEventListener("click", () => {
          resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-info-circle me-2"></i> To install, tap "Share" in Safari and select "Add to Home Screen".</p>`;
        });
      } else {
        installButton.addEventListener("click", () => {
          resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-info-circle me-2"></i> Please install this app from your browser's menu.</p>`;
        });
      }
    }

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      console.log('Install prompt available');
      showInstallPrompt();
    });

    window.addEventListener('appinstalled', () => {
      console.log('PWA was installed!');
      installButton.classList.add("d-none");
      deferredPrompt = null;
    });

    function resetAppState() {
      if (balanceInterval) clearInterval(balanceInterval);
      balanceInterval = null;
      isAuthenticated = false;
      walletHeader.style.display = "block";
      bottomMenu.classList.add("d-none");
      resultElement.innerHTML = "";
      generateButton.classList.add("d-none");
      biometricButton.classList.add("d-none");
    }

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden" && isAuthenticated) {
        resetAppState();
      } else if (document.visibilityState === "visible" && hasWallet()) {
        resetAppState();
        walletHeader.style.display = "block";
        handleWalletAction(false);
      }
    });

    window.addEventListener("load", () => {
      if (!isAuthenticated) resetAppState();

      if (storedCredentialId && storedEncryptedWif) {
        handleWalletAction(false);
      } else {
        generateButton.classList.remove("d-none");
        biometricButton.classList.add("d-none");
      }
    });

    async function handleWalletAction(isGenerate = false) {
      resultElement.innerHTML = `<p><i class="fa-solid fa-spinner fa-spin me-2"></i> Much authenticating...</p>`;
      
      if (isGenerate) {
        generateButton.classList.add("d-none");
      } else {
        biometricButton.classList.add("d-none");
      }

      try {
        let result;
        if (isGenerate) {
          result = await registerWebAuthn();
          localStorage.setItem('dogeCredentialId', result.credentialId);
          localStorage.setItem('dogeEncryptedWif', result.encryptedWif);
          localStorage.setItem('dogeIv', result.iv);
          storedCredentialId = result.credentialId;
          storedEncryptedWif = result.encryptedWif;
          result.isNew = true;
          installButton.classList.add("d-none");
        } else {
          result = await authenticateWebAuthn(storedCredentialId);
          if (result.credentialId !== storedCredentialId) throw new Error("Much sad! Credential ID mismatch.");
        }

        if (!result || !result.privateKey || !result.address) throw new Error("Much sad! Failed to retrieve credentials");

        isAuthenticated = true;
        walletHeader.style.display = "none";
        bottomMenu.classList.remove("d-none");

        let walletData = await getDogeBalanceAndTransactions(result.address);

        const showWalletView = () => {
          resultElement.innerHTML = `
            <h1 class="mb-3" id="balanceDisplay"><i class="fa-solid fa-coins me-2"></i> √ê ${walletData.balance}</h1>
            <div id="qrCode" class="mb-3"></div>
            <div class="input-group mb-3">
              <input type="text" id="address" class="form-control" value="${result.address}" readonly>
              <button class="btn btn-outline-secondary" type="button" id="copyAddress">
                <i class="fa-solid fa-copy"></i>
              </button>
            </div>
            <div class="transactions-container" id="transactionsList"></div>
          `;
          
          new QRCode(document.getElementById("qrCode"), {
            text: result.address,
            width: 512,
            height: 512
          });

          const transactionsList = document.getElementById("transactionsList");
          if (walletData.transactions.length > 0) {
            walletData.transactions.forEach(tx => {
              const txDiv = document.createElement('div');
              txDiv.className = 'transaction-item';
              txDiv.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                  <span>${trimAddress(tx.tx_type === 'RECEIVED' ? tx.address : tx.destination_address)}</span>
                  <span class="badge ${tx.tx_type === 'RECEIVED' ? 'badge-received' : 'badge-spent'}">
                    ${tx.tx_type === 'RECEIVED' ? '+' : '-'}${tx.amount} √ê
                  </span>
                </div>
              `;
              txDiv.addEventListener('click', () => showTransactionDetails(tx, showWalletView));
              transactionsList.appendChild(txDiv);
            });
          } else {
            //transactionsList.innerHTML = '<p class="text-muted text-center">No transactions yet</p>';
          }

          document.getElementById("copyAddress").addEventListener("click", () => {
            navigator.clipboard.writeText(result.address).then(() => {
              alert("Much wow! Address copied to clipboard!");
            });
          });
        };

        const urlParams = new URLSearchParams(window.location.search);
        const url = window.location.href;
        if (url.startsWith("dogecoin:")) {
          const qrMatch = url.match(/dogecoin:([A-Za-z0-9]+)(\?amount=([\d.]+))?/);
          if (qrMatch) {
            const destinationAddress = qrMatch[1];
            const amount = qrMatch[3] || '';
            handleSendFromUrl(result, destinationAddress, amount, walletData.balance);
          }
        } else {
          showWalletView();
        }

        const updateBalanceAndTransactions = async () => {
          walletData = await getDogeBalanceAndTransactions(result.address);
          document.getElementById("balanceDisplay").innerHTML = `<i class="fa-solid fa-coins me-2"></i> √ê ${walletData.balance}`;
          const transactionsList = document.getElementById("transactionsList");
          if (transactionsList) {
            transactionsList.innerHTML = '';
            if (walletData.transactions.length > 0) {
              walletData.transactions.forEach(tx => {
                const txDiv = document.createElement('div');
                txDiv.className = 'transaction-item';
                txDiv.innerHTML = `
                  <div class="d-flex justify-content-between align-items-center">
                    <span>${trimAddress(tx.tx_type === 'RECEIVED' ? tx.address : tx.destination_address)}</span>
                    <span class="badge ${tx.tx_type === 'RECEIVED' ? 'badge-received' : 'badge-spent'}">
                      ${tx.tx_type === 'RECEIVED' ? '+' : '-'}${tx.amount} √ê
                    </span>
                  </div>
                `;
                txDiv.addEventListener('click', () => showTransactionDetails(tx, showWalletView));
                transactionsList.appendChild(txDiv);
              });
            } else {
              //transactionsList.innerHTML = '<p class="text-muted text-center">No transactions yet</p>';
            }
          }
        };

        balanceInterval = setInterval(updateBalanceAndTransactions, 5000);

        document.getElementById("walletBtn").addEventListener("click", () => {
          if (!isAuthenticated) return handleWalletAction(false);
          if (balanceInterval) clearInterval(balanceInterval);
          balanceInterval = setInterval(updateBalanceAndTransactions, 5000);
          showWalletView();
        });

        document.getElementById("sendBtn").addEventListener("click", async () => {
          if (!isAuthenticated) return handleWalletAction(false);
          if (balanceInterval) clearInterval(balanceInterval);
          const qrResult = await scanQRCode();
          let destinationAddress = '';
          let amount = '';

          if (qrResult) {
            const qrMatch = qrResult.match(/dogecoin:([A-Za-z0-9]+)(\?amount=([\d.]+))?/);
            if (qrMatch) {
              destinationAddress = qrMatch[1];
              amount = qrMatch[3] || '';
            } else {
              destinationAddress = qrResult;
            }
          }

          resultElement.innerHTML = `
            <h1 class="mb-3"><i class="fa-solid fa-coins me-2"></i> √ê ${walletData.balance}</h1>
            <div class="input-group mb-3">
              <span class="input-group-text" id="basic-addon1"><i class="fa-solid fa-wallet"></i></span>
              <input type="text" id="destinationAddress" class="form-control" value="${destinationAddress}" placeholder="Enter √êogecoin address">
            </div> 
            <div class="input-group mb-3">
              <span class="input-group-text" id="basic-addon1">√ê</span>
              <input type="number" id="amount" class="form-control" value="${amount}" placeholder="Enter amount in √êoge" step="0.00000001">
            </div> 
            <button id="confirmSend" class="btn btn-view btn-lg w-100"><i class="fa-solid fa-paw"></i> Send Money</button>
            <button id="cancelSend" class="btn btn-secondary w-100 mt-2"><i class="fa-solid fa-xmark"></i> Cancel</button>
          `;

          document.getElementById("confirmSend").addEventListener("click", async () => {
            const finalDestination = document.getElementById("destinationAddress").value;
            const finalAmount = document.getElementById("amount").value;

            if (!finalDestination || !finalAmount) {
              alert("Much oops! Please enter both destination address and amount.");
              return;
            }

            if (parseFloat(finalAmount) > parseFloat(walletData.balance)) {
              alert("Much oops! Insufficient balance.");
              return;
            }

            resultElement.innerHTML = `<p><i class="fa-solid fa-spinner fa-spin me-2"></i> Much Sending Doge...</p>`;
            const sendResult = await sendDoge(result.address, finalDestination, finalAmount, result.privateKey);

            if (sendResult.status === 'success') {
              walletData = await getDogeBalanceAndTransactions(result.address);
              showWalletView();
              resultElement.innerHTML += `<p class="text-success"><i class="fa-solid fa-check-circle me-2"></i> Much wow! Doge sent successfully!</p>`;
              balanceInterval = setInterval(updateBalanceAndTransactions, 5000);
            } else {
              resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-exclamation-triangle me-2"></i> Much sad! Send failed: ${sendResult.message}</p>`;
            }
          });

          document.getElementById("cancelSend").addEventListener("click", () => {
            showWalletView();
            balanceInterval = setInterval(updateBalanceAndTransactions, 5000);
          });
        });

        document.getElementById("configBtn").addEventListener("click", () => {
          if (!isAuthenticated) return handleWalletAction(false);
          if (balanceInterval) clearInterval(balanceInterval);
          resultElement.innerHTML = `
            <div id="privateKeyContainer" class="mb-3">
              <button id="showPrivateKey" class="btn btn-outline-secondary w-100"><i class="fa-solid fa-key"></i> Show Private Key</button>
            </div>
            <button id="cleanCache" class="btn btn-outline-info w-100 mb-3"><i class="fa-solid fa-broom"></i> Clean Local Cache</button>
            <button id="logoutWallet" class="btn btn-outline-warning w-100 mb-3"><i class="fa-solid fa-right-from-bracket"></i> Logout</button>
            <button id="deleteWallet" class="btn btn-outline-danger w-100 mb-3"><i class="fa-solid fa-trash"></i> Delete Wallet</button>
          `;

          const showPrivateKeyButton = document.getElementById("showPrivateKey");
          const handleShowPrivateKey = () => {
            if (confirm("Much warning! Keep a copy of your private key secure in multiple locations. Without the private key, all Doge is lost! Show it now?")) {
              document.getElementById("privateKeyContainer").innerHTML = `
                <div class="input-group">
                  <input type="text" id="privateKeyInput" class="form-control" value="${result.privateKey}" readonly>
                  <button class="btn btn-outline-secondary" type="button" id="hidePrivateKey">
                    <i class="fa-solid fa-eye-slash"></i>
                  </button>
                </div>
              `;
              document.getElementById("hidePrivateKey").addEventListener("click", () => {
                document.getElementById("privateKeyContainer").innerHTML = `<button id="showPrivateKey" class="btn btn-outline-secondary w-100">Show Private Key</button>`;
                document.getElementById("showPrivateKey").addEventListener("click", handleShowPrivateKey);
              });
            }
          };
          showPrivateKeyButton.addEventListener("click", handleShowPrivateKey);

          document.getElementById("cleanCache").addEventListener("click", async () => {
            if (confirm("Much wow! This will clear cached static files (e.g., offline app data). Wallet will remain intact. Proceed?")) {
              try {
                if ('serviceWorker' in navigator) {
                  const registrations = await navigator.serviceWorker.getRegistrations();
                  for (let registration of registrations) {
                    await registration.unregister();
                  }
                  console.log('Service Workers unregistered');
                }

                if ('caches' in window) {
                  const cacheNames = await caches.keys();
                  for (let name of cacheNames) {
                    await caches.delete(name);
                  }
                  console.log('Caches cleared');
                }

                if ('serviceWorker' in navigator) {
                  await navigator.serviceWorker.register('./js/service-worker.js', { scope: './js/' });
                  console.log('Service Worker re-registered');
                }

                resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-check-circle me-2"></i> Much wow! Local cache cleaned. App will refresh cached files.</p>`;
              } catch (error) {
                console.error('Error cleaning cache:', error);
                resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-exclamation-triangle me-2"></i> Much sad! Failed to clean cache: ${error.message}</p>`;
              }
            }
          });

          document.getElementById("logoutWallet").addEventListener("click", () => {
            if (confirm("Logout and require biometric re-authentication?")) {
              resetAppState();
              if (hasWallet()) {
                biometricButton.classList.remove("d-none");
              }
            }
          });

          document.getElementById("deleteWallet").addEventListener("click", () => {
            resultElement.innerHTML = `
              <p class="text-muted">Much warning! Confirm deletion by entering your full Doge Address:</p>
              <div class="input-group mb-3">
                <input type="text" id="confirmAddress" class="form-control" placeholder="Enter your Doge Address">
                <button class="btn btn-outline-danger" type="button" id="confirmDelete">Confirm Delete</button>
              </div>
              <button id="cancelDelete" class="btn btn-secondary w-100">Cancel</button>
            `;
            document.getElementById("confirmDelete").addEventListener("click", () => {
              const enteredAddress = document.getElementById("confirmAddress").value;
              if (enteredAddress === result.address) {
                localStorage.removeItem('dogeCredentialId');
                localStorage.removeItem('dogeEncryptedWif');
                localStorage.removeItem('dogeIv');
                storedCredentialId = null;
                storedEncryptedWif = null;
                resetAppState();
                resultElement.innerHTML = `<p class="text-muted">Wow, wallet deleted. Click 'Generate Biometric Wallet' to create a new one.</p>`;
                generateButton.classList.remove("d-none");
                showInstallPrompt();
              } else {
                alert("Much oops! Address does not match. Deletion canceled.");
              }
            });
            document.getElementById("cancelDelete").addEventListener("click", () => {
              document.getElementById("configBtn").click();
            });
          });
        });

      } catch (error) {
        if (balanceInterval) {
          clearInterval(balanceInterval);
          balanceInterval = null;
        }
        console.error("Much sad! Detailed error:", error);
        let errorMessage = "Much sad, error occurred";
        if (error.message.includes("not supported")) {
          errorMessage = "Much oops! WebAuthn not supported";
        } else if (error.message.includes("Authentication failed") || error.message.includes("canceled")) {
          errorMessage = "Much oops! Biometric authentication failed or canceled";
        } else if (error.message.includes("Decryption failed") || error.message.includes("OperationError")) {
          errorMessage = "Much oops! Decryption error - key mismatch or data corruption";
        } else if (error.message.includes("Credential ID mismatch")) {
          errorMessage = "Much oops! Wrong biometric authenticator used";
        } else if (error.message.includes("public key")) {
          errorMessage = "Much oops! Authenticator did not provide public key";
        } else {
          errorMessage = `Much oops! Failed: ${error.message}`;
        }
        resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-exclamation-triangle me-2"></i> ${errorMessage}</p>`;
        
        if (isGenerate) {
          generateButton.classList.remove("d-none");
        } else if (!storedCredentialId || !storedEncryptedWif) {
          generateButton.classList.remove("d-none");
        } else {
          biometricButton.classList.remove("d-none");
        }
      }
    }

    async function handleSendFromUrl(result, destinationAddress, amount, balance) {
      resultElement.innerHTML = `
        <h1 class="mb-3"><i class="fa-solid fa-coins me-2"></i> √ê ${balance}</h1>
        <div class="mb-3">
          <label for="destinationAddress" class="form-label">Destination Address</label>
          <input type="text" id="destinationAddress" class="form-control" value="${destinationAddress}" readonly>
        </div>
        <div class="mb-3">
          <label for="amount" class="form-label">Amount (√ê)</label>
          <input type="number" id="amount" class="form-control" value="${amount}" readonly>
        </div>
        <button id="confirmSend" class="btn btn-primary w-100">Confirm Send</button>
        <button id="cancelSend" class="btn btn-secondary w-100 mt-2">Cancel</button>
      `;

      document.getElementById("confirmSend").addEventListener("click", async () => {
        if (parseFloat(amount) > parseFloat(balance)) {
          alert("Much oops! Insufficient balance.");
          return;
        }

        resultElement.innerHTML = `<p><i class="fa-solid fa-spinner fa-spin me-2"></i> Sending Doge...</p>`;
        const sendResult = await sendDoge(result.address, destinationAddress, amount, result.privateKey);

        if (sendResult.status === 'success') {
          walletData = await getDogeBalanceAndTransactions(result.address);
          showWalletView();
          resultElement.innerHTML += `<p class="text-success"><i class="fa-solid fa-check-circle me-2"></i> Much wow! Doge sent successfully!</p>`;
          balanceInterval = setInterval(updateBalanceAndTransactions, 5000);
        } else {
          resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-exclamation-triangle me-2"></i> Much sad! Send failed: ${sendResult.message}</p>`;
        }
      });

      document.getElementById("cancelSend").addEventListener("click", () => {
        showWalletView();
        balanceInterval = setInterval(updateBalanceAndTransactions, 5000);
      });
    }

    generateButton.addEventListener("click", () => handleWalletAction(true));
    biometricButton.addEventListener("click", () => handleWalletAction(false));

    if (!isRunningStandalone() && !hasWallet()) {
      showInstallPrompt();
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(registrations => {
        if (registrations.length === 0) {
          navigator.serviceWorker.register('./js/service-worker.js', { scope: './js/' })
            .then(registration => {
              console.log('Service Worker registered with scope:', registration.scope);
              registration.update();
              resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-check-circle me-2"></i> Much wow! App cached for offline use.</p>`;
              if (!hasWallet()) showInstallPrompt();
            })
            .catch(error => {
              console.error('Service Worker registration failed:', error);
              resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-exclamation-triangle me-2"></i> Much sad! Offline caching failed: ${error.message}</p>`;
            });
        } else {
          console.log('Service Worker already registered');
        }
      }).catch(err => console.error('Error checking registrations:', err));
    } else {
      console.log('Service Workers not supported');
      resultElement.innerHTML = `<p class="text-muted"><i class="fa-solid fa-exclamation-triangle me-2"></i> Much sad! Offline mode not supported.</p>`;
    }
  </script>
</body>
</html>